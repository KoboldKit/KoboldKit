<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/OGWMap.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/OGWMap</TokenIdentifier>
			<Abstract type="html">An arbitrary map represented by a memory buffer. Can be used for collision, heat, surface and other map types as you see fit.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
            
			
			<NodeRef refid="18"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setWorld:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>@property (weak) OGWWorld *world</Declaration>
			
			
			<Anchor>//api/name/world</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/world</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>@property (weak) OGWWorld *world</Declaration>
			
			
			<Anchor>//api/name/world</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/world</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>@property (weak) OGWWorld *world</Declaration>
			
			
			<Anchor>//api/name/world</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setSize:</TokenIdentifier>
			<Abstract type="html">The size makes the map a 2D buffer, determining how many elements per row and column exist.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWIntSize size</Declaration>
			
			<ReturnValue><Abstract type="html">The size of the map, in map (integer) coordinates.</Abstract></ReturnValue>
			<Anchor>//api/name/size</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/size</TokenIdentifier>
			<Abstract type="html">The size makes the map a 2D buffer, determining how many elements per row and column exist.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWIntSize size</Declaration>
			
			<ReturnValue><Abstract type="html">The size of the map, in map (integer) coordinates.</Abstract></ReturnValue>
			<Anchor>//api/name/size</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
			<Abstract type="html">The size makes the map a 2D buffer, determining how many elements per row and column exist.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWIntSize size</Declaration>
			
			<ReturnValue><Abstract type="html">The size of the map, in map (integer) coordinates.</Abstract></ReturnValue>
			<Anchor>//api/name/size</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setElementSize:</TokenIdentifier>
			<Abstract type="html">How you interpret the size of an element is up to you. Most often it would be used to indicate the spacing between two elements
in world coordinates, respectively the area each element occupies in the world.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property GWSize elementSize</Declaration>
			
			<ReturnValue><Abstract type="html">The size of individual elements in the map, in arbitrary units (typically world coordinates). Defaults to {1, 1}.</Abstract></ReturnValue>
			<Anchor>//api/name/elementSize</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementSize</TokenIdentifier>
			<Abstract type="html">How you interpret the size of an element is up to you. Most often it would be used to indicate the spacing between two elements
in world coordinates, respectively the area each element occupies in the world.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property GWSize elementSize</Declaration>
			
			<ReturnValue><Abstract type="html">The size of individual elements in the map, in arbitrary units (typically world coordinates). Defaults to {1, 1}.</Abstract></ReturnValue>
			<Anchor>//api/name/elementSize</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
			<Abstract type="html">How you interpret the size of an element is up to you. Most often it would be used to indicate the spacing between two elements
in world coordinates, respectively the area each element occupies in the world.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property GWSize elementSize</Declaration>
			
			<ReturnValue><Abstract type="html">The size of individual elements in the map, in arbitrary units (typically world coordinates). Defaults to {1, 1}.</Abstract></ReturnValue>
			<Anchor>//api/name/elementSize</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setElementCount:</TokenIdentifier>
			<Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWUInteger elementCount</Declaration>
			
			<ReturnValue><Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract></ReturnValue>
			<Anchor>//api/name/elementCount</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementCount</TokenIdentifier>
			<Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWUInteger elementCount</Declaration>
			
			<ReturnValue><Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract></ReturnValue>
			<Anchor>//api/name/elementCount</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementCount</TokenIdentifier>
			<Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/size</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementSize</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) GWUInteger elementCount</Declaration>
			
			<ReturnValue><Abstract type="html">The number of elements in the map. This is equal to (size.width * size``.</Abstract></ReturnValue>
			<Anchor>//api/name/elementCount</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setMap:</TokenIdentifier>
			<Abstract type="html">Gives you low-level access to the map data (elements). In most cases you&apos;re bette off to use the enumeration methods.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAtPoint:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAt:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsUsingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsIntersectingRect:usingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsInRect:usingBlock:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) void *map</Declaration>
			
			<ReturnValue><Abstract type="html">Pointer to the start of the map&apos;s memory buffer.</Abstract></ReturnValue>
			<Anchor>//api/name/map</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/map</TokenIdentifier>
			<Abstract type="html">Gives you low-level access to the map data (elements). In most cases you&apos;re bette off to use the enumeration methods.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAtPoint:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAt:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsUsingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsIntersectingRect:usingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsInRect:usingBlock:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) void *map</Declaration>
			
			<ReturnValue><Abstract type="html">Pointer to the start of the map&apos;s memory buffer.</Abstract></ReturnValue>
			<Anchor>//api/name/map</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
			<Abstract type="html">Gives you low-level access to the map data (elements). In most cases you&apos;re bette off to use the enumeration methods.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAtPoint:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAt:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsUsingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsIntersectingRect:usingBlock:</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsInRect:usingBlock:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) void *map</Declaration>
			
			<ReturnValue><Abstract type="html">Pointer to the start of the map&apos;s memory buffer.</Abstract></ReturnValue>
			<Anchor>//api/name/map</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setElementBytes:</TokenIdentifier>
			<Abstract type="html">The elementBytes determine the integral byte size of each element in the map. No assumption is made how many bytes each element
in the map occupies, hence the map is a void* type and can be used for any element types like char, integer or double.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t elementBytes</Declaration>
			
			<ReturnValue><Abstract type="html">The size in bytes of each element. Typically either 1 (char), 2 (short), 4 (int, float) or 8 (long, double) bytes.</Abstract></ReturnValue>
			<Anchor>//api/name/elementBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementBytes</TokenIdentifier>
			<Abstract type="html">The elementBytes determine the integral byte size of each element in the map. No assumption is made how many bytes each element
in the map occupies, hence the map is a void* type and can be used for any element types like char, integer or double.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t elementBytes</Declaration>
			
			<ReturnValue><Abstract type="html">The size in bytes of each element. Typically either 1 (char), 2 (short), 4 (int, float) or 8 (long, double) bytes.</Abstract></ReturnValue>
			<Anchor>//api/name/elementBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
			<Abstract type="html">The elementBytes determine the integral byte size of each element in the map. No assumption is made how many bytes each element
in the map occupies, hence the map is a void* type and can be used for any element types like char, integer or double.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t elementBytes</Declaration>
			
			<ReturnValue><Abstract type="html">The size in bytes of each element. Typically either 1 (char), 2 (short), 4 (int, float) or 8 (long, double) bytes.</Abstract></ReturnValue>
			<Anchor>//api/name/elementBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setMapBytes:</TokenIdentifier>
			<Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t mapBytes</Declaration>
			
			<ReturnValue><Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract></ReturnValue>
			<Anchor>//api/name/mapBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/mapBytes</TokenIdentifier>
			<Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t mapBytes</Declaration>
			
			<ReturnValue><Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract></ReturnValue>
			<Anchor>//api/name/mapBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/mapBytes</TokenIdentifier>
			<Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/map</TokenIdentifier>
		<TokenIdentifier>//apple_ref/occ/instp/OGWMap/elementBytes</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property (readonly) size_t mapBytes</Declaration>
			
			<ReturnValue><Abstract type="html">How much memory (in bytes) the map occupies. This is equal to (elementCount * elementBytes``.</Abstract></ReturnValue>
			<Anchor>//api/name/mapBytes</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/setType:</TokenIdentifier>
			<Abstract type="html">You can optionally assign a map a type from the OGWMapType list or your own. This allows you to get a map based on its type instead of by name.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/cl/OGWWorldMaps</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property OGWMapType type</Declaration>
			
			<ReturnValue><Abstract type="html">The map&apos;s predefined type.</Abstract></ReturnValue>
			<Anchor>//api/name/type</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/type</TokenIdentifier>
			<Abstract type="html">You can optionally assign a map a type from the OGWMapType list or your own. This allows you to get a map based on its type instead of by name.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/cl/OGWWorldMaps</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property OGWMapType type</Declaration>
			
			<ReturnValue><Abstract type="html">The map&apos;s predefined type.</Abstract></ReturnValue>
			<Anchor>//api/name/type</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/OGWMap/type</TokenIdentifier>
			<Abstract type="html">You can optionally assign a map a type from the OGWMapType list or your own. This allows you to get a map based on its type instead of by name.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/cl/OGWWorldMaps</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>@property OGWMapType type</Declaration>
			
			<ReturnValue><Abstract type="html">The map&apos;s predefined type.</Abstract></ReturnValue>
			<Anchor>//api/name/type</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/OGWMap/mapWithBytes:elementBytes:size:</TokenIdentifier>
			<Abstract type="html">Copies the contents of the buffer. This is slower and allocated another buffer of the same size, which doubles memory usage
until you free the buffer. If this concerns you, use the no-copy initializer..</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/clm/OGWMap/mapWithBytesNoCopy:elementBytes:size:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>+ (id)mapWithBytes:(const void *const)buffer elementBytes:(size_t)elementBytes size:(GWIntSize)size</Declaration>
			<Parameters>
				<Parameter>
					<Name>buffer</Name>
					<Abstract type="html">An allocated memory buffer.</Abstract>
				</Parameter><Parameter>
					<Name>elementBytes</Name>
					<Abstract type="html">The size of each element, in bytes. For example for a GWInteger* buffer you would pass sizeof(GWInteger).</Abstract>
				</Parameter><Parameter>
					<Name>size</Name>
					<Abstract type="html">The size of the map, ie how many elements per row and column.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new map instance.</Abstract></ReturnValue>
			<Anchor>//api/name/mapWithBytes:elementBytes:size:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/OGWMap/mapWithBytesNoCopy:elementBytes:size:</TokenIdentifier>
			<Abstract type="html">Takes ownership of the buffer without copying it. This is faster and more memory efficient.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/clm/OGWMap/mapWithBytesNoCopy:elementBytes:size:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>+ (id)mapWithBytesNoCopy:(void *const)buffer elementBytes:(size_t)elementBytes size:(GWIntSize)size</Declaration>
			<Parameters>
				<Parameter>
					<Name>buffer</Name>
					<Abstract type="html">An allocated memory buffer.</Abstract>
				</Parameter><Parameter>
					<Name>elementBytes</Name>
					<Abstract type="html">The size of each element, in bytes. For example for a GWInteger* buffer you would pass sizeof(GWInteger).</Abstract>
				</Parameter><Parameter>
					<Name>size</Name>
					<Abstract type="html">The size of the map, ie how many elements per row and column.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">A new map instance.</Abstract></ReturnValue>
			<Anchor>//api/name/mapWithBytesNoCopy:elementBytes:size:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/reverseRows</TokenIdentifier>
			<Abstract type="html">Flips the map&apos;s rows by copying them into a new buffer and releasing the old buffer. This is a slow operation, run this only
when your buffer&apos;s positive Y coordinates extend downwards (origin at upper left) instead of the OpenGW (OpenGL) coordinate system where
positive Y coordinates extend upwards (origin at lower left).</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (void)reverseRows</Declaration>
			
			
			<Anchor>//api/name/reverseRows</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/mapCoordFromPoint:inBounds:</TokenIdentifier>
			<Abstract type="html">A point in world coordinates.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (GWIntPoint)mapCoordFromPoint:(GWPoint)point inBounds:(BOOL *const)inBounds</Declaration>
			<Parameters>
				<Parameter>
					<Name>point</Name>
					<Abstract type="html">A point in world coordinates.</Abstract>
				</Parameter><Parameter>
					<Name>inBounds</Name>
					<Abstract type="html">Pass nil if you don&apos;t want to perform bounds checking (faster). Pass a pointer to a BOOL if you want to perform bounds checking.
The inBounds parameter will be YES if the returned coordinate is within the map&apos;s boundaries, NO if it is outside the map&apos;s boundaries - in that
case the returned coordinates can not be used to access the map&apos;s elements.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The corresponding point in map coordinates, taking elementSize into account. The point may lie outside the bounds of the map.</Abstract></ReturnValue>
			<Anchor>//api/name/mapCoordFromPoint:inBounds:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/mapCoordRectFromPointRect:inBounds:</TokenIdentifier>
			<Abstract type="html">A rect in world coordinates.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (GWIntRect)mapCoordRectFromPointRect:(GWRect)rect inBounds:(BOOL *const)inBounds</Declaration>
			<Parameters>
				<Parameter>
					<Name>rect</Name>
					<Abstract type="html">A rect in world coordinates.</Abstract>
				</Parameter><Parameter>
					<Name>inBounds</Name>
					<Abstract type="html">Pass nil if you don&apos;t want to perform bounds checking (faster). Pass a pointer to a BOOL if you want to perform bounds checking.
The inBounds parameter will be YES if the returned rectangle is entirely within the map&apos;s boundaries, NO if the rectangle is at least partially
outside the map&apos;s boundaries - in that case the returned rectangle can not be used to access the map&apos;s elements.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The corresponding rect in map coordinates, taking elementSize into account. The rectangle may lie (partially or completely) outside the bounds of the map.</Abstract></ReturnValue>
			<Anchor>//api/name/mapCoordRectFromPointRect:inBounds:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAt:</TokenIdentifier>
			<Abstract type="html">A position in element coordinates.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAtPoint:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>- (void *const)elementAt:(GWIntPoint)position</Declaration>
			<Parameters>
				<Parameter>
					<Name>position</Name>
					<Abstract type="html">A position in element coordinates.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The element at the given position. Returns NULL if the position was outside the map&apos;s boundaries.</Abstract></ReturnValue>
			<Anchor>//api/name/elementAt:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAtPoint:</TokenIdentifier>
			<Abstract type="html">This considers the elementSize of elements to determine which element to return.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
	<RelatedTokens>
		<TokenIdentifier>//apple_ref/occ/instm/OGWMap/elementAt:</TokenIdentifier>
		
	</RelatedTokens>
	
			<Declaration>- (void *const)elementAtPoint:(GWPoint)point</Declaration>
			<Parameters>
				<Parameter>
					<Name>point</Name>
					<Abstract type="html">A point in world coordinates.</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract type="html">The element at the given point. Returns NULL if the point was outside the map&apos;s boundaries.</Abstract></ReturnValue>
			<Anchor>//api/name/elementAtPoint:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsUsingBlock:</TokenIdentifier>
			<Abstract type="html">Enumerates all elements.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (void)enumerateElementsUsingBlock:(OGWMapElementEnumerationBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to run for each element.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/enumerateElementsUsingBlock:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsIntersectingRect:usingBlock:</TokenIdentifier>
			<Abstract type="html">Enumerates the elements intersecting the rect (in world coordinates).</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (void)enumerateElementsIntersectingRect:(GWRect)rect usingBlock:(OGWMapElementEnumerationBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>rect</Name>
					<Abstract type="html">A rectangle in world coordinates. The rect may be partially or completely outside the map&apos;s boundaries,
it will be adjusted accordingly and return only elements within the map&apos;s boundaries, if any.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to run for each intersecting element.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/enumerateElementsIntersectingRect:usingBlock:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/enumerateElementsInRect:usingBlock:</TokenIdentifier>
			<Abstract type="html">Enumerates the elements at the coordinates given by the rect (in element coordinates).</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (void)enumerateElementsInRect:(GWIntRect)rect usingBlock:(OGWMapElementEnumerationBlock)block</Declaration>
			<Parameters>
				<Parameter>
					<Name>rect</Name>
					<Abstract type="html">A rectangle in element coordinates. The rect may be partially or completely outside the map&apos;s boundaries,
it will be adjusted accordingly and return only elements within the map&apos;s boundaries, if any.</Abstract>
				</Parameter><Parameter>
					<Name>block</Name>
					<Abstract type="html">The block to run for each intersecting element.</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/enumerateElementsInRect:usingBlock:</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/OGWMap/debugDumpMap</TokenIdentifier>
			<Abstract type="html">The map as string with coordinate markers. Mainly for printing to the console and further analysis.</Abstract>
			<DeclaredIn>OGWMap.h</DeclaredIn>
			
			<Declaration>- (NSString *)debugDumpMap</Declaration>
			
			<ReturnValue><Abstract type="html">The map as string with coordinate markers. Mainly for printing to the console and further analysis.</Abstract></ReturnValue>
			<Anchor>//api/name/debugDumpMap</Anchor>
            <NodeRef refid="18"/>
		</Token>
		
        
	</File>
</Tokens>